import mongodb from 'mongodb';

const { MongoClient } = mongodb;
let client;
const models = {};
export const connection = { readyState: 0, name: null };
export const version = '0.0.0-stub';

export async function connect(uri, options = {}) {
  client = new MongoClient(uri, options);
  await client.connect();
  connection.readyState = 1;
  try { connection.name = client.db().databaseName; } catch { connection.name = null; }
  return client;
}

export class Schema {
  constructor(definition = {}, options = {}) {
    this.definition = definition;
    this.options = options;
    this._indexes = [];
  }

  index(fields, options = {}) {
    if (!fields || typeof fields !== 'object') {
      throw new TypeError('Schema.index requires a fields object');
    }
    this._indexes.push({ fields, options });
    return this;
  }

  getIndexes() {
    return this._indexes.map(({ fields, options }) => ({ fields: { ...fields }, options: { ...options } }));
  }
}

export function model(name, schema) {
  if (models[name]) return models[name];
  const collectionName = schema?.options?.collection || name.toLowerCase();
  const m = {
    create: (doc) => {
      if (!client) throw new Error('MongoClient not connected');
      const collection = client.db().collection(collectionName);
      return collection.insertOne(doc);
    },
    find: (filter = {}, projection = {}) => {
      if (!client) throw new Error('MongoClient not connected');
      const collection = client.db().collection(collectionName);
      let cursor = collection.find(filter, { projection });
      const chain = {
        sort(sort) {
          cursor = cursor.sort(sort);
          return chain;
        },
        lean() {
          return cursor.toArray();
        }
      };
      return chain;
    },
    findOne: (filter = {}, projection = {}, options = {}) => {
      if (!client) throw new Error('MongoClient not connected');
      const collection = client.db().collection(collectionName);
      let cursor = collection.find(filter, { projection });
      if (options.sort) cursor = cursor.sort(options.sort);
      const promise = cursor.limit(1).next();
      return { lean: () => promise };
    },
    findOneAndUpdate: (filter, update) => {
      if (!client) throw new Error('MongoClient not connected');
      const collection = client.db().collection(collectionName);
      return collection.findOneAndUpdate(filter, { $set: update });
    },
    deleteOne: (filter = {}) => {
      if (!client) throw new Error('MongoClient not connected');
      const collection = client.db().collection(collectionName);
      return collection.deleteOne(filter);
    }
  };
  models[name] = m;
  return m;
}

export function modelNames() {
  return Object.keys(models);
}

export const modelsRegistry = models;

export default { connect, Schema, model, models: modelsRegistry, modelNames, connection, version };
